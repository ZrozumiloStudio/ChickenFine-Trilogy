<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Rendering with Camera</title>
<style>
    canvas { border: 1px solid black; }
</style>
</head>
<body>
<canvas id="canvas" width="1500" height="690"></canvas>
<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Положение и ориентация камеры
    let cameraPosition = { x: 20, y: 20, z: 40 };
    let cameraRotation = { x: 0, y: 0, z: 0 };
	
	function deBugengine() {
		console.log(cameraPosition);	
	}
	
	setInterval(deBugengine, 1000);

    // Массив полигонов с их вершинами
    const polygons = [
        [
            { x: 10, y: 10, z: 0 },
            { x: 30, y: 10, z: 0 },
            { x: 20, y: 30, z: 10 }
        ],
        [
            { x: 15, y: 20, z: 5 },
            { x: 25, y: 20, z: 5 },
            { x: 20, y: 30, z: 15 }
        ],
        // Добавьте здесь другие полигоны по аналогии
    ];

    // Функция для рисования полигона
    function drawPolygon(vertices) {
        ctx.beginPath();
        ctx.moveTo(vertices[0].x, vertices[0].y);
        for (let i = 1; i < vertices.length; i++) {
            ctx.lineTo(vertices[i].x, vertices[i].y);
        }
        ctx.closePath();
        ctx.fillStyle = '#659465';
        ctx.fill();
        ctx.stroke();
    }

    // Функция для проекции вершин на экран с учетом положения и ориентации камеры
    function projectVertex(vertex) {
        // Переводим вершину в систему координат камеры
        const translatedVertex = {
            x: vertex.x - cameraPosition.x,
            y: vertex.y - cameraPosition.y,
            z: vertex.z - cameraPosition.z
        };

        // Вращаем вершину в соответствии с ориентацией камеры
        const rotatedVertex = {
            x: translatedVertex.x * Math.cos(cameraRotation.y) - translatedVertex.z * Math.sin(cameraRotation.y),
            y: translatedVertex.y,
            z: translatedVertex.x * Math.sin(cameraRotation.y) + translatedVertex.z * Math.cos(cameraRotation.y)
        };

        // Проецируем вершину на экран
        const scale = 500; // Масштаб
        const x = (rotatedVertex.x * scale / -rotatedVertex.z) + (canvas.width / 2);
        const y = (rotatedVertex.y * scale / -rotatedVertex.z) + (canvas.height / 2);
        return { x, y };
    }

    // Функция для обновления и отображения сцены
    function updateScene() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Рисуем все полигоны на Canvas
        polygons.forEach(polygon => {
            const projectedVertices = polygon.map(projectVertex);
            drawPolygon(projectedVertices);
        });
    }

    // Обработчики событий изменения ориентации камеры и движения камеры
    document.addEventListener('keydown', (event) => {
        const stepRotation = 0.1; // Шаг вращения камеры
        const stepMovement = 1; // Шаг движения камеры

        if (event.key === 'ArrowLeft') {
            cameraRotation.y -= stepRotation;
        } else if (event.key === 'ArrowRight') {
            cameraRotation.y += stepRotation;
        } else if (event.key === 'w' || event.key === 'W') {
            cameraPosition.z -= stepMovement;
        } else if (event.key === 's' || event.key === 'S') {
            cameraPosition.z += stepMovement;
        } else if (event.key === 'a' || event.key === 'A') {
            cameraPosition.x -= stepMovement;
        } else if (event.key === 'd' || event.key === 'D') {
            cameraPosition.x += stepMovement;
        }

        updateScene();
    });

    // Обновляем и отображаем сцену при загрузке страницы
    updateScene();
</script>
</body>
</html>
